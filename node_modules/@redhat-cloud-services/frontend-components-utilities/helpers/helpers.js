"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toUpperCase = exports.generateFilter = exports.getBaseName = exports.processDate = exports.downloadFile = exports.mergeArraysByKey = exports.JSON_TYPE = exports.CSV_TYPE = void 0;
var merge_1 = __importDefault(require("lodash/merge"));
var mapKeys_1 = __importDefault(require("lodash/mapKeys"));
exports.CSV_TYPE = 'text/csv;charset=utf-8;';
exports.JSON_TYPE = 'data:text/json;charset=utf-8,';
var monthMap = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];
function mergeArraysByKey(arrays, key) {
    if (key === void 0) { key = 'id'; }
    var mergedObject = merge_1.default.apply(void 0, arrays.map(function (row) { return (0, mapKeys_1.default)(row, function (a) { return a && a[key]; }); }));
    return Object.values(mergedObject);
}
exports.mergeArraysByKey = mergeArraysByKey;
function downloadFile(data, filename, format) {
    if (filename === void 0) { filename = "".concat(new Date().toISOString()); }
    if (format === void 0) { format = exports.CSV_TYPE; }
    var type = format === 'json' ? exports.JSON_TYPE : exports.CSV_TYPE;
    var blob = new Blob([data], { type: type });
    var link = document.createElement('a');
    link.setAttribute('href', URL.createObjectURL(blob));
    link.setAttribute('download', "".concat(filename, ".").concat(format));
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}
exports.downloadFile = downloadFile;
function processDate(dateString) {
    var date = new Date(dateString);
    var month = monthMap[date.getMonth()];
    var day = date.getDate() < 10 ? "0".concat(date.getDate()) : date.getDate();
    if (!month || isNaN(day)) {
        return 'N/A';
    }
    return "".concat(day, " ").concat(month, " ").concat(date.getFullYear());
}
exports.processDate = processDate;
function getBaseName(pathname, level) {
    if (level === void 0) { level = 2; }
    var release = '/';
    var pathName = pathname.replace(/(#|\?).*/, '').split('/');
    pathName.shift();
    if (pathName[0] === 'beta') {
        pathName.shift();
        release = "/beta/";
    }
    return __spreadArray([], new Array(level), true).reduce(function (acc, _curr, key) {
        return "".concat(acc).concat(pathName[key] || '').concat(key < level - 1 ? '/' : '');
    }, release);
}
exports.getBaseName = getBaseName;
var generateFilter = function (data, path, options) {
    if (path === void 0) { path = 'filter'; }
    return Object.entries(data || {}).reduce(function (acc, _a) {
        var _b;
        var key = _a[0], value = _a[1];
        var newPath = "".concat(path || '', "[").concat(key, "]").concat(Array.isArray(value) ? "".concat((options === null || options === void 0 ? void 0 : options.arrayEnhancer) ? "[".concat(options.arrayEnhancer, "]") : '', "[]") : '');
        if (value instanceof Function || value instanceof Date) {
            return acc;
        }
        return __assign(__assign({}, acc), (Array.isArray(value) || typeof value !== 'object' ? (_b = {}, _b[newPath] = value, _b) : (0, exports.generateFilter)(value, newPath, options)));
    }, {});
};
exports.generateFilter = generateFilter;
var toUpperCase = function (text) {
    if (text === void 0) { text = ''; }
    return "".concat(text.charAt(0).toUpperCase()).concat(text.slice(1));
};
exports.toUpperCase = toUpperCase;
//# sourceMappingURL=helpers.js.map