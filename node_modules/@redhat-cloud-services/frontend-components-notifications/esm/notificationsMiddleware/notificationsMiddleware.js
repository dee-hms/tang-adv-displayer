var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import get from 'lodash/get';
import has from 'lodash/has';
import { addNotification } from '../redux/actions/notifications';
import { AlertVariant } from '@patternfly/react-core';
var prepareErrorMessage = function (payload, errorTitleKey, errorDescriptionKey) {
    if (typeof payload === 'string') {
        return {
            title: 'Error',
            description: payload,
        };
    }
    var titleKey = errorTitleKey;
    if (Array.isArray(errorTitleKey)) {
        titleKey = errorTitleKey.find(function (key) { return has(payload, key); });
    }
    var descriptionKey = errorDescriptionKey;
    if (Array.isArray(errorDescriptionKey)) {
        descriptionKey = errorDescriptionKey.find(function (key) { return has(payload, key); });
    }
    return {
        title: get(payload, titleKey) || 'Error',
        description: get(payload, descriptionKey),
        sentryId: payload === null || payload === void 0 ? void 0 : payload.sentryId,
        requestId: payload === null || payload === void 0 ? void 0 : payload.requestId,
    };
};
var shouldDispatchDefaultError = function (_a) {
    var isRejected = _a.isRejected, hasCustomNotification = _a.hasCustomNotification, noErrorOverride = _a.noErrorOverride, dispatchDefaultFailure = _a.dispatchDefaultFailure;
    return isRejected && !hasCustomNotification && !noErrorOverride && dispatchDefaultFailure;
};
export var createNotificationsMiddleware = function (options) {
    var defaultOptions = {
        dispatchDefaultFailure: true,
        pendingSuffix: '_PENDING',
        fulfilledSuffix: '_FULFILLED',
        rejectedSuffix: '_REJECTED',
        autoDismiss: false,
        dismissDelay: 5000,
        errorTitleKey: 'title',
        errorDescriptionKey: 'detail',
        useStatusText: false,
    };
    var middlewareOptions = __assign(__assign({}, defaultOptions), options);
    var matchPending = function (type) { return Boolean(type.match(new RegExp("^.*".concat(middlewareOptions.pendingSuffix, "$")))); };
    var matchFulfilled = function (type) { return Boolean(type.match(new RegExp("^.*".concat(middlewareOptions.fulfilledSuffix, "$")))); };
    var matchRejected = function (type) { return Boolean(type.match(new RegExp("^.*".concat(middlewareOptions.rejectedSuffix, "$")))); };
    var defaultNotificationOptions = {
        dismissable: !middlewareOptions.autoDismiss,
        dismissDelay: middlewareOptions.dismissDelay,
    };
    var middleware = function (_a) {
        var dispatch = _a.dispatch;
        return function (next) {
            return function (action) {
                var meta = action.meta, type = action.type;
                if (meta && meta.notifications) {
                    var notifications = meta.notifications;
                    if (matchPending(type) && notifications.pending) {
                        if (typeof notifications.pending === 'function') {
                            notifications.pending = notifications.pending(action.payload);
                        }
                        dispatch(addNotification(__assign(__assign({}, defaultNotificationOptions), notifications.pending)));
                    }
                    else if (matchFulfilled(type) && notifications.fulfilled) {
                        if (typeof notifications.fulfilled === 'function') {
                            notifications.fulfilled = notifications.fulfilled(action.payload);
                        }
                        dispatch(addNotification(__assign(__assign({}, defaultNotificationOptions), notifications.fulfilled)));
                    }
                    else if (matchRejected(type) && notifications.rejected) {
                        if (typeof notifications.rejected === 'function') {
                            notifications.rejected = notifications.rejected(action.payload);
                        }
                        dispatch(addNotification(__assign(__assign(__assign({}, defaultNotificationOptions), notifications.rejected), { sentryId: action.payload && action.payload.sentryId, requestId: action.payload && action.payload.requestId })));
                    }
                }
                if (shouldDispatchDefaultError({
                    isRejected: matchRejected(type),
                    hasCustomNotification: meta && meta.notifications && meta.notifications.rejected,
                    noErrorOverride: meta && meta.noError,
                    dispatchDefaultFailure: middlewareOptions.dispatchDefaultFailure,
                })) {
                    if (middlewareOptions.useStatusText) {
                        dispatch(addNotification(__assign({ variant: AlertVariant.danger, dismissable: true }, prepareErrorMessage(action.payload, middlewareOptions.errorTitleKey, 'statusText'))));
                    }
                    else {
                        var namespaceKey = Array.isArray(middlewareOptions.errorNamespaceKey) && middlewareOptions.errorNamespaceKey.find(function (key) { return has(action.payload, key); });
                        if (namespaceKey) {
                            get(action.payload, namespaceKey).map(function (item) {
                                dispatch(addNotification(__assign({ variant: AlertVariant.danger, dismissable: true }, prepareErrorMessage(item, middlewareOptions.errorTitleKey, middlewareOptions.errorDescriptionKey))));
                            });
                        }
                        else {
                            if (Array.isArray(action.payload)) {
                                action.payload.map(function (item) {
                                    dispatch(addNotification(__assign({ variant: AlertVariant.danger, dismissable: true }, prepareErrorMessage(item, middlewareOptions.errorTitleKey, middlewareOptions.errorDescriptionKey))));
                                });
                            }
                            else {
                                dispatch(addNotification(__assign({ variant: AlertVariant.danger, dismissable: true }, prepareErrorMessage(action.payload, middlewareOptions.errorTitleKey, middlewareOptions.errorDescriptionKey))));
                            }
                        }
                    }
                }
                next(action);
            };
        };
    };
    return middleware;
};
export default createNotificationsMiddleware;
//# sourceMappingURL=notificationsMiddleware.js.map