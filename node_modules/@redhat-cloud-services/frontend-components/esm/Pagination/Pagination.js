var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { jsx as _jsx } from "react/jsx-runtime";
import PaginationNext from './PaginationNext';
export var dropDirection = {
    up: 'up',
    down: 'down',
};
var pager = [10, 15, 20, 25, 50];
var Pagination = function (_a) {
    var _b = _a.page, page = _b === void 0 ? 1 : _b, onSetPage = _a.onSetPage, numberOfItems = _a.numberOfItems, itemsPerPage = _a.itemsPerPage, perPageOptions = _a.perPageOptions, onPerPageSelect = _a.onPerPageSelect, onFirstPage = _a.onFirstPage, onLastPage = _a.onLastPage, onPreviousPage = _a.onPreviousPage, onNextPage = _a.onNextPage, direction = _a.direction, props = __rest(_a, ["page", "onSetPage", "numberOfItems", "itemsPerPage", "perPageOptions", "onPerPageSelect", "onFirstPage", "onLastPage", "onPreviousPage", "onNextPage", "direction"]);
    var setPage = function (nextPage, debounce) {
        var perPage = itemsPerPage || pager[0];
        var maxPage = Math.ceil(numberOfItems / perPage);
        var result = isNaN(nextPage) ? page : nextPage;
        result = result > maxPage ? maxPage : result < 0 ? 0 : result;
        onSetPage && onSetPage(result, debounce);
    };
    var pagerOptions = perPageOptions || pager;
    var perPage = itemsPerPage || pagerOptions[0];
    var lastPage = Math.ceil(numberOfItems / perPage);
    var lastIndex = numberOfItems === 0 ? 0 : page === lastPage ? numberOfItems : page * perPage;
    var firstIndex = numberOfItems === 0 ? 0 : (page - 1) * perPage + 1;
    return (_jsx(PaginationNext, __assign({}, props, { itemCount: numberOfItems, className: "ins-c-pagination-next", itemsStart: firstIndex, itemsEnd: lastIndex, lastPage: lastPage || 1, dropDirection: direction, onFirstPage: onFirstPage, onLastPage: onLastPage, onPreviousPage: onPreviousPage, onNextPage: onNextPage, perPage: perPage, onSetPerPage: function (_event, value) { return onPerPageSelect(value); }, page: page, setPage: function (event, page) { return setPage(page, event.currentTarget.tagName === 'INPUT'); }, perPageOptions: pagerOptions.map(function (value) { return ({
            title: value,
            value: value,
        }); }) })));
};
export default Pagination;
//# sourceMappingURL=Pagination.js.map